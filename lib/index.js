"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const node_dir_1 = require("node-dir");
const DEFAULT_PROJECT_BASE_PATH = process.cwd();
const DEFAULT_USE_RECURSIVE = true;
/**
 * default regexp used to search files, different from the one in webpack(/^\.\/.*$/)
 * the default regexp will match every file
 */
const DEFAULT_REGEXP = /^.*$/;
const REQUIRE_CONTEXT_STRING_PREFIX = '__require_context_for_vite';
const PLUGIN_NAME = '@originjs/vite-plugin-require-context';
const GENERATED_CODE_COMMENT = `// generated by ${PLUGIN_NAME}\n`;
const requireContextRegex = /require\.context\(([\w\W]+?)\)($|\)|;|\n|\r\n)/g;
exports.default = (options = {}) => {
    return {
        name: 'vite:require-context',
        async transform(code, id) {
            const nodeModulesPath = '/node_modules/';
            // do not handle the files in node_modules
            if (id.includes(nodeModulesPath)) {
                return null;
            }
            const requireContextMatches = [...code.matchAll(requireContextRegex)];
            // only handle the files that contains require.context
            if (requireContextMatches.length === 0) {
                return null;
            }
            let transformedCode = code;
            let addedCode = '';
            // there may be multiple calls of require.context. We need to handle them separately
            requireContextMatches.forEach((requireContextMatch, index) => {
                const { paramsSyntax, tobeReplacedSyntax } = handleRequireContextSyntax(requireContextMatch[0]);
                const params = paramsSyntax.split(',');
                const directory = params[0] || '';
                const recursive = (!params[1]) ? DEFAULT_USE_RECURSIVE : eval(params[1]);
                const regExp = (!params[2]) ? DEFAULT_REGEXP : eval(params[2]);
                const projectPath = (!params[4]) ? '' : eval(params[4]);
                const { importsString, key2FilesMapString, contextFunctionString, requireContextFunctionName } = transformRequireContext(eval(directory), recursive, regExp, id, options.projectBasePath, index, projectPath);
                const generatedRequireContextStart = `\n// start of generated code of ${requireContextFunctionName}, generated by ${PLUGIN_NAME}\n`;
                const generatedRequireContextEnd = `// end of generated code of ${requireContextFunctionName}\n`;
                addedCode += generatedRequireContextStart + importsString + key2FilesMapString + contextFunctionString + generatedRequireContextEnd;
                transformedCode = transformedCode.replace(tobeReplacedSyntax, requireContextFunctionName);
            });
            transformedCode = GENERATED_CODE_COMMENT + addedCode + transformedCode;
            return { code: transformedCode };
        },
    };
};
function handleRequireContextSyntax(originalSyntax) {
    if (!originalSyntax.startsWith('require.context')) {
        throw new Error(`Unexpected syntax met. Syntax does not start with 'require.context'`);
    }
    const stack = [];
    let paramsStart;
    let paramsEnd;
    for (let i = 0; i < originalSyntax.length; i++) {
        if (originalSyntax.charAt(i) == '(') {
            stack.push('(');
            if (stack.length == 1) {
                paramsStart = i + 1;
            }
            continue;
        }
        if (originalSyntax.charAt(i) == ')') {
            stack.pop();
            if (stack.length == 0) {
                paramsEnd = i;
                break;
            }
        }
    }
    return { 'paramsSyntax': originalSyntax.substring(paramsStart, paramsEnd), 'tobeReplacedSyntax': originalSyntax.substring(0, paramsEnd + 1) };
}
/**
 * Transform all the calls of require.context
 *
 * @param directory the directory from which to require the files. It's the first parameter of require.context
 * @param recursive search recursively or not. It's the second parameter of require.context
 * @param regExp the regex used to match files. It's the third parameter of require.context
 * @param workingFilePath the path of the file being transformed
 * @param projectBasePath the base path of the project
 * @param matchIndex the occurrence index of require.context
 */
function transformRequireContext(directory, recursive = DEFAULT_USE_RECURSIVE, regExp = DEFAULT_REGEXP, workingFilePath, projectBasePath = DEFAULT_PROJECT_BASE_PATH, matchIndex, projectPath) {
    let basePath;
    switch (directory[0]) {
        // relative path, starting with ./ or ../
        case '.':
            basePath = path.join(workingFilePath, '..' + path.sep, directory);
            break;
        // path based on the project base path
        case '/':
            basePath = path.join(projectBasePath, directory);
            break;
        // path based on the /src
        case '@':
            basePath = path.join(projectBasePath, 'src', directory.substr(1));
            break;
        // search in node_modules
        default:
            basePath = path.join(projectBasePath, 'node_modules', directory);
    }
    // for windows, the path.join will return with a path ending with a '/'
    // for linux/macos, the path.join will return with a path ending without '/'
    basePath = basePath.replace(/\\/g, '/');
    if (basePath.endsWith('/')) {
        basePath = basePath.substring(0, basePath.length - 1);
    }
    const absolutePaths = (0, node_dir_1.files)(basePath, {
        sync: true,
        recursive: recursive,
    })
        .map(function (path) {
        // deal with the file separator in windows
        let p = path.replace(/\\/g, '/');
        return './' + p.slice(basePath.length + 1);
    })
        .filter(function (file) {
        return file.match(regExp);
    })
        .map(function (path) {
        return basePath + path.slice(1);
    });
    // the actual files to be imported
    const importedFiles = absolutePaths.map((absolutePath) => {
        return projectPath ? '.' + absolutePath.slice(projectBasePath.length).slice(projectPath.length) : absolutePath.slice(projectBasePath.length);
    });
    // the keys of require.context
    const keys = absolutePaths.map((absolutePath) => {
        return './' + absolutePath.slice(basePath.length + 1);
    });
    const requireContextMapName = `${REQUIRE_CONTEXT_STRING_PREFIX}_map_${matchIndex}`;
    const requireContextFunctionName = `${REQUIRE_CONTEXT_STRING_PREFIX}_function_${matchIndex}`;
    const key2FilesMap = generateKey2FilesMap(keys, importedFiles, matchIndex);
    const importsString = generateImportsString(keys, importedFiles, matchIndex);
    const key2FilesMapString = generateKey2FilesMapString(key2FilesMap, requireContextMapName);
    const contextFunctionString = generateContextFunctionString(requireContextFunctionName, requireContextMapName);
    return {
        importsString,
        key2FilesMapString,
        contextFunctionString,
        requireContextFunctionName
    };
}
/**
 * Generate a map with imported entry and relative file path
 *
 * @param keys the keys of require.context
 * @param importedFiles the actual files to be imported
 * @param matchIndex the occurrence index of require.context
 */
function generateKey2FilesMap(keys, importedFiles, matchIndex) {
    let key2FilesMap = {};
    keys.forEach((key, index) => {
        const importEntry = `${REQUIRE_CONTEXT_STRING_PREFIX}_${matchIndex}_${index}`;
        key2FilesMap[key] = {
            'importEntry': importEntry,
            'filePath': './' + importedFiles[index]
        };
    });
    return key2FilesMap;
}
/**
 * Generate the import string. The import string is something like :
 * import * as __require_context_for_vite_0_0 from "/src/components/a.vue";
 * import * as __require_context_for_vite_0_1 from "/src/components/b.vue";
 * import * as __require_context_for_vite_0_2 from "/src/components/c.vue";
 *
 * @param keys the keys of require.context
 * @param importedFiles the actual files to be imported
 * @param matchIndex the occurrence index of require.context
 */
function generateImportsString(keys, importedFiles, matchIndex) {
    let importsString = '';
    for (let index = 0; index < keys.length; index++) {
        const importEntry = `${REQUIRE_CONTEXT_STRING_PREFIX}_${matchIndex}_${index}`;
        importsString += `import * as ${importEntry} from "${importedFiles[index]}";\n`;
    }
    importsString += '\n';
    return importsString;
}
/**
 * Generate the map of require.context. The map is something like :
 * var __require_context_for_vite_map_0 = {
 *	"./a.vue" : __require_context_for_vite_0_0,
 *	"./b.vue" : __require_context_for_vite_0_1,
 *	"./c.vue" : __require_context_for_vite_0_2
 * };
 *
 * @param key2FilesMap map generated by generateKey2FilesMap
 * @param requireContextMapName the name of the generated map. It's something like __require_context_for_vite_map_0
 */
function generateKey2FilesMapString(key2FilesMap, requireContextMapName) {
    // return empty object if no files are matched
    if (Object.keys(key2FilesMap).length == 0) {
        return `var ${requireContextMapName} = {};\n`;
    }
    let key2FilesMapString = `var ${requireContextMapName} = {\n`;
    Object.keys(key2FilesMap).forEach((key) => {
        key2FilesMapString += `\t"${key}" : ${key2FilesMap[key].importEntry},\n`;
    });
    key2FilesMapString = key2FilesMapString.substring(0, key2FilesMapString.length - 2) + '\n};\n';
    return key2FilesMapString;
}
/**
 * Generate the function of require.context. The function is something like :
 * function __require_context_for_vite_function_0(req) {
 *    var id = __require_context_for_vite_function_0_resolve(req);
 *    return __require_context_for_vite_map_0[req];
 * }
 * function __require_context_for_vite_function_0_resolve(req) {
 *    if (req in __require_context_for_vite_map_0) {
 *        return __require_context_for_vite_map_0[req];
 *    }
 *    var e = new Error("Cannot find module '" + req + "'");
 *    e.code = 'MODULE_NOT_FOUND';
 *    throw e;
 * }
 * __require_context_for_vite_function_0.keys = function __require_context_for_vite_function_0_keys() {
 *    return Object.keys(__require_context_for_vite_map_0);
 * }
 * __require_context_for_vite_function_0.resolve = __require_context_for_vite_function_0_resolve
 * __require_context_for_vite_function_0.id = "__require_context_for_vite_function_0"
 *
 * @param requireContextFunctionName the name of the generated function. It's something like __require_context_for_vite_function_0
 * @param requireContextMapName the name of the generated map. It's something like __require_context_for_vite_map_0
 */
function generateContextFunctionString(requireContextFunctionName, requireContextMapName) {
    const requireContextResolveFunctionName = `${requireContextFunctionName}_resolve`;
    const requireContextKeysFunctionName = `${requireContextFunctionName}_keys`;
    // webpackContext(req)
    let contextFunctionString = `function ${requireContextFunctionName}(req) {
    var id = ${requireContextResolveFunctionName}(req);
    return ${requireContextMapName}[req];
}\n`;
    // webpackContextResolve(req)
    contextFunctionString += `function ${requireContextResolveFunctionName}(req) {
    if (req in ${requireContextMapName}) {
        return ${requireContextMapName}[req];
    }
    var e = new Error("Cannot find module '" + req + "'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
}\n`;
    // webpackConext.keys
    contextFunctionString += `${requireContextFunctionName}.keys = function ${requireContextKeysFunctionName}() {
    return Object.keys(${requireContextMapName});
}\n`;
    // webpackContext.resolve
    contextFunctionString += `${requireContextFunctionName}.resolve = ${requireContextResolveFunctionName}\n`;
    // webpackContext.id
    // TODO: not implemented as webpack did
    contextFunctionString += `${requireContextFunctionName}.id = "${requireContextFunctionName}"\n`;
    return contextFunctionString;
}
